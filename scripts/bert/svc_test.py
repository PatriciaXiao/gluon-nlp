import numpy as np

import matplotlib.pyplot as plt
import numpy as np  
from sklearn.svm import SVC  

# http://www.machinelearningtutorial.net/2016/12/10/python-svm/#m1
# https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html

X = np.array([[2.85225797, 0.],
     [2.93938112, 0.],
     [2.32653689, 0.],
     [3.20769596, 0.],
     [2.50110292, 0.],
     [2.74856758, 0.],
     [2.34768701, 0.],
     [2.63620615, 0.],
     [3.10402179, 0.], 
     [3.25548005, 0.], 
     [3.2242589 , 0.], 
     [2.8941226 , 0.], 
     [2.77163219, 0.], 
     [3.13367057, 0.], 
     [3.0664885 , 0.], 
     [2.33734465, 0.], 
     [3.18818521, 0.], 
     [2.46791553, 0.], 
     [2.54324341, 0.], 
     [3.55956101, 0.], 
     [2.30429435, 0.], 
     [2.33923841, 0.], 
     [3.0537591 , 0.], 
     [2.34042096, 0.], 
     [3.35983133, 0.], 
     [3.19644165, 0.], 
     [2.57492638, 0.], 
     [2.55594516, 0.], 
     [2.2650044 , 0.], 
     [2.8443327 , 0.], 
     [3.26606679, 0.], 
     [2.37013745, 0.], 
     [3.29041243, 0.], 
     [3.20673275, 0.], 
     [2.14603281, 0.], 
     [3.10267878, 0.], 
     [2.60819101, 0.], 
     [3.30423427, 0.], 
     [2.5299921 , 0.], 
     [3.34893465, 0.], 
     [2.50838995, 0.], 
     [2.78786588, 0.], 
     [2.73144102, 0.], 
     [3.67248535, 0.], 
     [2.80196905, 0.], 
     [2.77713823, 0.], 
     [2.76427293, 0.], 
     [2.31659579, 0.], 
     [3.67917919, 0.], 
     [3.06422377, 0.], 
     [2.55387783, 0.], 
     [1.94631386, 0.], 
     [3.3632102 , 0.], 
     [2.3587718 , 0.], 
     [2.61273599, 0.], 
     [1.93489075, 0.], 
     [2.60092878, 0.], 
     [2.72776151, 0.], 
     [2.19706678, 0.], 
     [3.17768216, 0.], 
     [3.15465236, 0.], 
     [3.13678408, 0.], 
     [2.97425628, 0.], 
     [2.94958949, 0.], 
     [2.19988561, 0.], 
     [2.52655935, 0.], 
     [3.41875219, 0.], 
     [2.74899101, 0.], 
     [4.58227777, 0.], 
     [2.49357128, 0.], 
     [2.51663327, 0.], 
     [2.37622428, 0.], 
     [3.24528027, 0.], 
     [2.54408574, 0.], 
     [3.01287293, 0.], 
     [3.10996294, 0.], 
     [3.0704751 , 0.], 
     [2.56283879, 0.], 
     [3.53959537, 0.], 
     [2.54891539, 0.], 
     [3.11256337, 0.], 
     [3.09313536, 0.], 
     [3.73695636, 0.], 
     [3.09887934, 0.], 
     [3.01350999, 0.], 
     [3.89441562, 0.], 
     [2.85534954, 0.], 
     [4.46888733, 0.], 
     [2.46555543, 0.], 
     [2.62967563, 0.], 
     [3.36556172, 0.], 
     [2.47922707, 0.], 
     [2.44500971, 0.], 
     [2.61866164, 0.], 
     [3.2263937 , 0.], 
     [2.26351023, 0.], 
     [2.60946178, 0.], 
     [3.29584217, 0.], 
     [3.2323966 , 0.], 
     [2.24986458, 0.], 
     [4.56159258, 0.], 
     [3.291116  , 0.], 
     [2.62658668, 0.], 
     [3.41776824, 0.], 
     [2.49941754, 0.], 
     [2.30417967, 0.], 
     [3.92098093, 0.], 
     [3.45178175, 0.], 
     [3.02981663, 0.], 
     [2.7961781 , 0.], 
     [2.19799995, 0.], 
     [2.54483414, 0.], 
     [1.70642424, 0.], 
     [2.17384601, 0.], 
     [4.4414773 , 0.], 
     [2.62963414, 0.], 
     [3.63789129, 0.], 
     [2.82681441, 0.], 
     [3.55169106, 0.], 
     [2.60926104, 0.], 
     [3.28557038, 0.], 
     [2.24772096, 0.], 
     [2.70114446, 0.], 
     [2.57273388, 0.], 
     [2.79165363, 0.], 
     [2.84786463, 0.], 
     [3.22600627, 0.]])

y = np.array([1., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 1., 1., 0., 0., 0., 1., 1., 0., 1., 1., 1., 1., 1.,
         1., 0., 0., 1., 0., 1., 1., 1., 0., 1., 1., 1., 1., 0., 1., 1., 1., 1., 0., 0., 0., 0., 0., 1.,
         0., 1., 0., 1., 1., 0., 1., 1., 1., 0., 0., 0., 0., 1., 0., 1., 1., 0., 0., 0., 0., 0., 1., 1.,
         0., 1., 0., 0., 1., 1., 0., 0., 0., 1., 0., 0., 0., 1., 1., 0., 0., 1., 0., 0., 0., 0., 1., 0.,
         1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 1., 0., 0., 1., 1., 1., 1., 1., 1., 0., 0., 1.,
         0., 1., 0., 0., 0., 1., 0.])

clf = SVC(kernel='linear', C=0.01, probability=True)
clf.fit(X, y) 

# below code is capable of plotting all of the above examples.

# Stepsize
h=.02 

# Define the borders of our grid using maxima from X and y
x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1

# Define the grid with the useful meshgrid function
xx, yy = np.meshgrid(np.arange(x_min, x_max, h),
                     np.arange(y_min, y_max, h))


# Plot the decision boundary
Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])
Z = Z.reshape(xx.shape)
plt.contourf(xx, yy, Z, cmap=plt.cm.autumn, alpha=1)


# Plot also the training points
plt.scatter(X[:, 0], X[:, 1], c=y, cmap=plt.cm.Paired, s=100)
plt.xlim(x_min, x_max)
plt.ylim(y_min, y_max)

plt.show()
